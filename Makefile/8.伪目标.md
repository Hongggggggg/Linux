- 所谓的伪目标可以这样来理解，它并不会创建目标文件，只是想去执行这个目标下面的命令。伪目标的存在可以帮助我们找到命令并执行。

  使用伪目标有两点原因：

  - 避免我们的 Makefile 中定义的只执行的命令的目标和工作目录下的实际文件出现名字冲突。
  - 提高执行 make 时的效率，特别是对于一个大型的工程来说，提高编译的效率也是我们所必需的。

- 将一个目标声明称伪目标的方法是将它作为特殊的目标`.PHONY`的依赖，如下：

  ```
  .PHONY:clean
  ```

  这样 clean 就被声明成一个伪目标，无论当前目录下是否存在 clean 这个文件，当我们执行 make clean 后 rm 都会被执行。而且当一个目标被声明为伪目标之后，make 在执行此规则时不会去试图去查找隐含的关系去创建它。这样同样提高了 make 的执行效率，同时也不用担心目标和文件名重名而使我们的编译失败。

  在书写伪目标的时候，需要声明目标是一个伪目标，之后才是伪目标的规则定义。目标 "clean" 的完整书写格式如下：

  ```makefile
  .PHONY:clean
  clean:
      rm -rf *.o test
  ```

- 伪目标实现多文件编辑

  如果在一个文件里想要同事生成多个可执行文件，我们可以借助伪目标来实现。方式如下：

  ```makefile
  .PHONY:all
  all:test1 test2 test3
  test1:test1.o
      gcc -o $@ $^
  test2:test2.o
      gcc -o $@ $^
  test3:test3.o
      gcc -o $@ $^
  ```

  ​	我们在当前目录下创建了三个源文件，目的是把这三个源文件编译成为三个可执行文件。将重建的规则放到 Makefile 中，约定使用 "all" 的伪目标来作为最终目标，它的依赖文件就是要生成的可执行文件。这样的话只需要一个 make 命令，就会同时生成三个可执行文件。

  ​	之所以这样写，是因为伪目标的特性，它总会被执行，所以它依赖的三个文件的目标就不如 "all" 这个目标新，所以，其他的三个目标的规则总是被执行，这也就达到了我们一口气生成多个目标的目的。我们也可以实现单独的编译这三个中的任意一个源文件（我们想去重建 test1，我们可以执行命令`make test1` 来实现 ）。 